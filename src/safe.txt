use futures::Future;
use crate::{route::Route};
use crate::responder::Responder;
use std::marker::PhantomData;
// use async_std::task;
// use crate::Request;
// use crate::extract::FromRequest;
use crate::web::FormDataExtractor;
use crate::http::{ServiceResponse,ServiceRequest};

pub struct ServiceConfig {
  pub routes:Vec<Route>,
}
pub trait ServiceConfigFactory {
  fn get_routes(&self) -> &Vec<Route>;
}
pub trait HttpServiceFactory {
  type Request;
  type Response;
  fn service_call(&self, param: Self::Request) -> Self::Response;
}

#[derive(Clone)]
pub(crate) struct HttpServiceFactoryWrapper<T, P, R, O> {
  factory: T,
  _t: PhantomData<(P, R, O)>
}

/**
  ......................................
  Implementations
  ......................................
*/

impl ServiceConfig {
  pub fn new() -> Self {
    ServiceConfig {
      routes: Vec::new(),
    }
  }
	
	pub fn service(&mut self, route: Route) {
    self.routes.push(route);
  }
}

impl ServiceConfigFactory for ServiceConfig {
  fn get_routes(&self) -> &Vec<Route> {
    &self.routes
  }
}

impl<T, P, R, O> HttpServiceFactoryWrapper<T, P, R, O> 
where 
  T: Factory<P, R, O>, 
  P: FormDataExtractor,
  R: Future<Output=O>, 
  O: Responder
{
  pub fn new(factory: T) -> Self {
    Self {
      factory,
      _t: PhantomData
    }
  }
}

impl<T, P, R, O> HttpServiceFactory for HttpServiceFactoryWrapper<T, P, R, O> 
where 
  T: Factory<P, R, O>, 
  P: FormDataExtractor,
  R: Future<Output=O>, 
  O: Responder 
{
  type Request = ServiceRequest;
  type Response = ServiceResponse;

  fn service_call(&self, param: Self::Request) -> Self::Response {
    let factory = &self.factory;
    factory.call(param)
  }
}


/**
  ......................................
  This is totally something else
  ......................................
*/
pub trait Factory<P, R, O>: Clone + 'static
where
  R: Future<Output=O>,
  O: Responder,
{
  fn call(&self, p: P) -> R;
}

impl<T, P, R, O> Factory<P, R, O> for T 
where 
  T: Fn(P) -> R + Clone + 'static, 
  R: Future<Output=O>, 
  O: Responder 
{
  fn call(&self, p: P) -> R {
    (self)(p)
  }
}
